总结：
1. JVM 基础知识
java 语言跨平台可以理解为Java字节码跨平台，java 源码文件通过编译编译成Java字节码文件，此过程即编译过程与平台无关，所有宣传一次编译多平台运行，差异体现在不同平台的JVM上。

整个Java代码的生命周期：Java源码----编译---> java 字节码 ------类加载------->JVM 方法区 --------> JVM 执行字节码

2. java 字节码技术

java 字节码：
	java 字节码由单个字节（1 byte）的指令组成，所有理论上最多支持256个指令。
	分类：
		1. 栈操作，包括与局部变量交互指令。（重要的指令：load 到栈上、store 到局部变量表中）
		2. 流程控制指令（if for while）
		3. 对象调用指令
		4. 算术运算、类型转换指令
		
javac -g 参数（class文件中可以看见局部变量表）
局部变量表：
	Start 和 Length 共同表示参数的作用范围 
	
JVM 方法操作的最小单位是int（int-long-float-double）， 因为方法操作时栈操作最终由CPU进行运算，所以最小单位和CPU是32位还是64位有关。
		
JVM 加载 Java字节码：
    JVM 加载，是指查找字节流，并且据此创建类的过程。对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。
	对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。
	类加载器加载类的步骤：
		1. 将类编译的class文件，以二进制流的形式加载到内存中  --- 加载 （加载不涉及类相关信息的验证，仅是）
		2. 验证、准备、解析类的二进制流相关信息。            --- 链接 
		3. 初始化类信息                              --- 初始化
	类加载器：
		最顶层类加载器： 启动类加载器（bootstrap class loader), 启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。
		ExtClassLoader:
		AppClassLoader:
		加载器特点：
		1. 双亲委托
		2. 负责依赖
		3. 缓存加载
		用途：通过打印不同类加载器加载的类信息，可以排除一些class加载失败的问题。
		问题： 什么时候需要自定义类加载器？？
	类的加载器只会加载其指定目录的class文件。不同的类加载器会加载不同目录文件的class文件。
链接
	链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。
	（验证、准备 对应defineClass方法，将字节流转换为Class实例，解析对应resolveClass方法）

初始化
	那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：
		1. 当虚拟机启动时，初始化用户指定的主类；
		2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
		3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
		4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
		5. 子类的初始化会触发父类的初始化；
		6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
		7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
		8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类
	不会初始化（可能会加载）
		1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 
		2. 定义对象数组，不会触发该类的初始化。 
		3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 
		4. 通过类名获取Class对象，不会触发类的初始化，Hello.class不会让Hello类初始 化。 
		5. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName （“jvm.Hello”）默认会加载Hello类。 
		6. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是 不初始化）。
	
		
JVM执行字节码：
	JVM是执行Java字节码的宿主环境或容器， 是一台基于栈的计算机器。
	JVM在运行过程中，都是基于线程执行Java中相关方法的字节码，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，
    栈帧的作用辅助JVM执行方法中的字节码，这个栈帧包含哪里内容：
		1. 辅助相关赋值及计算操作的操作数栈
		2. 局部变量表
		3. 当前Java方法所归属的Class
		
方法调用的指令：


JVM 内存模型：

JVM堆内存结构：

CPU与内存行为：

JMM规范：

JVM 启动参数：



	
		
